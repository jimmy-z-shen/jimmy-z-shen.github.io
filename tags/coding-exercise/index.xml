<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>coding exercise on Jimmy's Homepage</title><link>https://jimmy-z-shen.github.io/tags/coding-exercise/</link><description>Recent content in coding exercise on Jimmy's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sat, 20 Mar 2021 12:51:26 -0700</lastBuildDate><atom:link href="https://jimmy-z-shen.github.io/tags/coding-exercise/index.xml" rel="self" type="application/rss+xml"/><item><title>LC743</title><link>https://jimmy-z-shen.github.io/posts/2021/03/lc743/</link><pubDate>Sat, 20 Mar 2021 12:51:26 -0700</pubDate><guid>https://jimmy-z-shen.github.io/posts/2021/03/lc743/</guid><description>743. Network Delay Time LC743
Priority Queue
class Solution: def networkDelayTime(self, times: List[List[int]], n: int, k: int) -&amp;gt; int: graph = collections.defaultdict(list) for src, dst, time in times: graph[src].append((dst, time)) if k not in graph: return -1 pq = [(k, 0)] # dst = k, time = 0 visited = {} while len(pq) &amp;gt; 0: src, time = heapq.heappop(pq) if src in visited: continue visited[src] = time for dst, add_time in graph[src]: if dst not in visited: heapq.</description></item><item><title>LC1286</title><link>https://jimmy-z-shen.github.io/posts/2021/03/lc1286/</link><pubDate>Sun, 14 Mar 2021 17:21:52 -0700</pubDate><guid>https://jimmy-z-shen.github.io/posts/2021/03/lc1286/</guid><description>Combination / Permutation / Backtracking issue
class CombinationIterator: def __init__(self, characters: str, combinationLength: int): self.combinations = [] def backtrack(cur: str, i: int): if len(cur) == combinationLength: self.combinations.append(cur) elif len(cur) &amp;lt; combinationLength: for j in range(i + 1, len(characters)): backtrack(cur + characters[j], j) for i in range(len(characters)): backtrack(characters[i], i) def next(self) -&amp;gt; str: return self.combinations.pop(0) def hasNext(self) -&amp;gt; bool: return len(self.combinations) &amp;gt; 0 all back tracking problems: backtracking</description></item><item><title>LC784</title><link>https://jimmy-z-shen.github.io/posts/2021/03/lc784/</link><pubDate>Sun, 14 Mar 2021 16:36:17 -0700</pubDate><guid>https://jimmy-z-shen.github.io/posts/2021/03/lc784/</guid><description>class Solution: def letterCasePermutation(self, S: str) -&amp;gt; List[str]: result = [] def helper(i: int, char_list: List[str]): if i == len(S): result.append(&amp;#34;&amp;#34;.join(char_list)) return if S[i].isalpha(): char_list.append(S[i].swapcase()) helper(i + 1, char_list) char_list.pop() char_list.append(S[i]) helper(i + 1, char_list) char_list.pop() helper(0, []) return result similar question
LC1286</description></item><item><title>LC636</title><link>https://jimmy-z-shen.github.io/posts/2021/03/lc636/</link><pubDate>Sun, 14 Mar 2021 15:23:06 -0700</pubDate><guid>https://jimmy-z-shen.github.io/posts/2021/03/lc636/</guid><description>636. Exclusive Time of Functions LC636
When using stack, be careful for 3 things:
what element to store in the stack condition to push onto stack condition to pop out of stack Think of stack as a method to preserve a state for later use. Since we want to calculate the execution timing of a function. When we get a log saying a function has started, we need to preserve the state, stores [process_id] and [start_time].</description></item><item><title>LC792</title><link>https://jimmy-z-shen.github.io/posts/2021/03/lc792/</link><pubDate>Sat, 13 Mar 2021 22:17:35 -0800</pubDate><guid>https://jimmy-z-shen.github.io/posts/2021/03/lc792/</guid><description>792. Number of Matching Subsequences LC792
Note: We need to be careful about what kinds of input we may get
Given words might contains a lot of repeating words Given string s might be very long Not really focusing on any algorithm or structure.
The idea is to:
convert the 2D Grid into 1D array Make the shift k % (row * col) Convert 1D array back to 2D Grid class Solution: def numMatchingSubseq(self, s: str, words: List[str]) -&amp;gt; int: word_counts = Counter(words) total_count = 0 for word, count in word_counts.</description></item><item><title>LC1260</title><link>https://jimmy-z-shen.github.io/posts/2021/03/lc1260/</link><pubDate>Sat, 13 Mar 2021 12:08:10 -0800</pubDate><guid>https://jimmy-z-shen.github.io/posts/2021/03/lc1260/</guid><description>1260. Shift 2D Grid LC1260
Not really focusing on any algorithm or structure.
The idea is to:
convert the 2D Grid into 1D array Make the shift k % (row * col) Convert 1D array back to 2D Grid class Solution: def shiftGrid(self, grid: List[List[int]], k: int) -&amp;gt; List[List[int]]: row = len(grid) col = len(grid[0]) k = k % (row * col) arr = [] for each_row in grid: arr.</description></item></channel></rss>